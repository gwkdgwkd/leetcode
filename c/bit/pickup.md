# 位运算基本功能
#### &运算通常用于二进制取位操作，例如一个数&1的结果就是取二进制的最末位。
这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数为偶数，最末位为1表示该数为奇数。
```
if(n % 2 == 1){ // n是个奇数 } // 写成n%2的形式，编译器也会自动帮我们优化成位运算
if(n & 1 == 1){ // n是个奇数 }
```
​通常用来将某变量中的某些位清零而保留其他位不变，例如，如果需要将int型变量n的低8位全置成0，而其余位不变，则可以执行：
```
n= n & 0xffffff00; 或 n &= 0xffffff00; 如果n是short类型的，则n &= 0xff00;
```
​如果要判断一个int型的变量n的第7位（从左往右，从0开始数）是否为1，则只需看表达式n&0x80的值是否等于0x80即可。
#### |运算通常用于二进制特定位上的无条件赋值，例如一个数|1的结果就是把二进制最末位强行变成1。
如果需要把二进制最末位变成0，对这个数|1之后再减一就可以了，其实际意义就是把这个数强行变成最接近的偶数。
​通常用来将变量中的某些位置成1，而保留其他位不变，例如，如果需要int型变量n的低8位全置成1，而其余位不变，则可以执行：
```
​n | = 0xff；
```
#### ^运算通常用于对二进制的特定一位进行取反操作，因为异或可以这样定义：0和1异或0都不变，异或1则取反。
异或运算支持运算的交换律和结合律。
两个相同的数异或之后结果会等于0，即n^n=0。并且任何数与0异或等于它本身，即n^0=n。
^运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即(a^b)^b = a。
如果~的对象是无符号整数（不能表示负数），那么得到的值就是它与该类型上界的差，因为无符号类型的数是用$0000到$FFFF依次表示的。
​异或运算的特点是：
​a^b==c 那么 c^b ==a 以及 c^a ==b ，此规律可以用来做最简单的快速加密和解密。
​且一个数异或另一个数两次，得到的仍为这个数本身：​a ^ b ^ b = a
#### 非运算的定义是把内存中的0和1全部取反。使用非运算时要格外小心，你需要注意整数类型有没有符号。
#### 实际上，左移1位，就等于是乘以2，左移n位，就是乘以2的n次方，而左移操作比乘法操作快的多。
对于有符号数，如long、int、short、char类型变量，在右移时，符号位(即最高位)将一起移动，并且大多数C/C++编译器规定，如果原符号位为1，则右移时右边高位就补充1，原符号位为0，则右移时高位就补充0。
实际上，右移n位，就相当于左操作数除以2的n次方，并且将结果往小里取整。


| 功能                  | 示例                   | 位运算                  |
| :-------------------- | :--------------------- | :---------------------- |
| 去掉最后一位          | (101101->10110)        | x shr 1                 |
| 在最后加一个0         | (101101->1011010)      | x shl 1                 |
| 在最后加一个1         | (101101->1011011)      | x shl 1+1               |
| 把最后一位变成1       | (101100->101101)       | x or 1                  |
| 把最后一位变成0       | (101101->101100)       | x or 1-1                |
| 最后一位取反          | (101101->101100)       | x xor 1                 |
| 把右数第k位变成1      | (101001->101101,k=3)   | x or (1 shl (k-1))      |
| 把右数第k位变成0      | (101101->101001,k=3)   | x and not (1 shl (k-1)) |
| 右数第k位取反         | (101001->101101,k=3)   | x xor (1 shl (k-1))     |
| 取末三位              | (1101101->101)         | x and 7                 |
| 取末k位               | (1101101->1101,k=5)    | x and (1 shl k-1)       |
| 取右数第k位           | (1101101->1,k=4)       | x shr (k-1) and 1       |
| 把末k位变成1          | (101001->101111,k=4)   | x or (1 shl k-1)        |
| 末k位取反             | (101001->100110,k=4)   | x xor (1 shl k-1)       |
| 把右边连续的1变成0    | (100101111->100100000) | x and (x+1)             |
| 把右起第一个0变成1    | (100101111->100111111) | x or (x+1)              |
| 把右边连续的0变成1    | (11011000->11011111)   | x or (x-1)              |
| 取右边连续的1         | (100101111->1111)      | (x xor (x+1)) shr 1     |
| 去掉右起第一个1的左边 | (100101000->1000)      | x and (x xor (x-1))     |

# 几个有趣的位操作
1. 利用或操作`|`和空格将英文字符转换为小写
    ```
    ('a' | ' ') = 'a'
    ('A' | ' ') = 'a'
    ```
2. 用与操作`&`和下划线将英文字符转换为大写
    ```
    ('b' & '_') = 'B'
    ('B' & '_') = 'B'
    ```
3. 利用异或操作`^`和空格进行英文字符大小写互换
    ```
    ('d' ^ ' ') = 'D'
    ('D' ^ ' ') = 'd'
    ```
4. 判断两个数是否异号
    ```
    int x = -1, y = 2;
    bool f = ((x ^ y) < 0); // true
    int x = 3, y = 2;
    bool f = ((x ^ y) < 0); // false
    ```
   这个技巧还是很实用的，利用的是补码编码的符号位。
   如果不用位运算来判断是否异号，需要使用if else分支，还挺麻烦的。
   可能想利用乘积或者商来判断两个数是否异号，但是这种处理方式可能造成溢出，从而出现错误。
5. 不用临时变量交换两个数
    ```
    int a = 1, b = 2;
    a ^= b;
    b ^= a; // b=
    a ^= b;
    // 现在 a = 2, b = 1
    x = x^y   
    y = x^y   // y = x^y = (x^y)^y = x^(y^y) = x^0 = x
    x = x^y   // x = x^y = (x^y)^x = (x^x)^y = 0^y = y
    ```
6. 加一
    ```
    int n = 1;
    n = -~n;
    // 现在 n = 2
    ```
7. 减一
    ```
    int n = 2;
    n = ~-n;
    // 现在 n = 1
    ```
8. m的n次方
   ```
    for(int i = 1; i <= n; i++) { // 时间复杂度为O(n)
        tmp = tmp * m;
    }  
    int pow(int n) { // 时间复杂度近为O(logn)
        int sum = 1;
        int tmp = m;
        while(n != 0) {
            if(n & 1 == 1){
                sum *= tmp;
            }
            tmp *= tmp;
            n = n >> 1;
        }
        
        return sum;
    } 
    ```
9. 找出不大于N的最大的2的幂指数（最左边的1保留，后面的1全部变为0）
    ```
    while(true) { // 时间复杂度是O(logn)
        if(sum * 2 > N){
            return sum;
        }
        sum = sum * 2;
    } 
    public static int findN2(int n) { // 时间复杂度近似O(1)
        // 1、找到最左边的1，然后把它右边的所有0变成1
        n |= n >> 1;
        n |= n >> 2;
        n |= n >> 4;
        n |= n >> 8;
        n |= n >> 16;
        // 2、把得到的数值加1，可以得到00100000即00011111+1=00100000。
        // 3、把得到的00100000向右移动一位，即可得到00010000，即00100000>>1=00010000。
        return (n + 1) >> 1;
    } 
    ```
10. 给定一个数，将某一位设置为1或者0
    ``` 
    num=num|(1<<(n-1)) // 设置位1
    num=nun&~(1<<n-1) // 设置为0
    ```
11. 给定一个整数num，求这个整数中二进制位0的个数
    ```
    int CountBitZero(int num) {
        int count = 0;
        while (num != -1) {
            ++count;
            num |= num + 1;
        }
        return count;
    }
    ```
12. 使用位运算求(a + b) / 2
    ```
    int Avg1(int a,int b) { // 方法一
        return a + ((b - a) >> 1);
    }  
    int Avg2(int a, int b) { // 方法二
        // a&b	=> 保存同为1的位
        // a^b	=> 保存相异的位
        return (a&b) + ((a^b) >> 1);
    }
    ```
13. 二进制中的1有奇数个还是偶数个
    ```
    // 32位的情况
    int x;
    scanf("%d", &x);
    x ^= x >> 1;
    x ^= x >> 2;
    x ^= x >> 4;
    x ^= x >> 8;
    x ^= x >> 16;
    printf("%d", x&1);
    ```
14. 二分查找32位整数的前导0个数
    ```
    int nlz(unsigned x) {
        int n;
            
        if (x == 0) return(32);
        n = 1;
        if ((x >> 16) == 0) {n = n +16; x = x <<16;}
        if ((x >> 24) == 0) {n = n + 8; x = x << 8;}
        if ((x >> 28) == 0) {n = n + 4; x = x << 4;}
        if ((x >> 30) == 0) {n = n + 2; x = x << 2;}
        n = n - (x >> 31);
        return n;
    }
    ```
15. 只用位运算来取绝对值
    ```
    假设x为32位整数，则x ^ (~(x >> 31) + 1) + x >> 31的结果是x的绝对值
    ```
16. 高低位交换
    ```
    (x >> 16) | (x << 16);
    ```

# 算法常用操作
n&(n-1)这个操作是算法中常见的，作用是消除数字n的二进制表示中的最后一个1。


# 位运算的黑科技
http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel