https://blog.csdn.net/w57w57w57/article/details/6634654
https://blog.csdn.net/w57w57w57/article/details/6638298
https://blog.csdn.net/w57w57w57/article/details/6657547
https://blog.csdn.net/w57w57w57/article/details/6657626
https://blog.csdn.net/w57w57w57/article/details/6657748




and运算通常用于二进制取位操作，例如一个数 and 1的结果就是取二进制的最末位。这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数为偶数，最末位为1表示该数为奇数.
​ 通常用来将某变量中的某些位清零而保留其他位不变，例如，如果需要将int型变量n的低8位全置成0，而其余位不变，则可以执行：

​ n= n & 0xffffff00;

​ 也可以写成：

​ n & = 0xffffff00;

​ 如果n是short类型的，则只需执行：

​ n & = 0xff00; 如果要判断一个int型的变量n的第7位（从左往右，从0开始数）是否为1，则只需看表达式 n &0x80的值是否等于0x80即可。

or运算通常用于二进制特定位上的无条件赋值，例如一个数or 1的结果就是把二进制最末位强行变成1。如果需要把二进制最末位变成0，对这个数or 1之后再减一就可以了，其实际意义就是把这个数强行变成最接近的偶数。
​ 通常用来将变量中的某些位置成1，而保留其他位不变，例如，如果需要int型变量n的低8位全置成1，而其余位不变，则可以执行：

​ n | = 0xff；

xor运算通常用于对二进制的特定一位进行取反操作，因为异或可以这样定义：0和1异或0都不变，异或1则取反。
xor运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即(a xor b) xor b = a。
not运算的定义是把内存中的0和1全部取反。使用not运算时要格外小心，你需要注意整数类型有没有符号。如果not的对象是无符号整数（不能表示负数），那么得到的值就是它与该类型上界的差，因为无符号类型的数是用$0000到$FFFF依次表示的。
​ 异或运算的特点是：

​ a^b==c 那么 c^b ==a 以及 c^a ==b ，此规律可以用来做最简单的快速加密和解密。

​ 且一个数异或另一个数两次，得到的仍为这个数本身：

​ a ^ b ^ b = a


实际上，左移1位，就等于是乘以2，左移n位，就是乘以2的n次方，而左移操作比乘法操作快的多。

对于有符号数，如long、int、short、char类型变量，在右移时，符号位(即最高位)将一起移动，并且大多数C/C++编译器规定，如果原符号位为1，则右移时右边高位就补充1，原符号位为0，则右移时高位就补充0。
实际上，右移n位，就相当于左操作数除以2的n次方，并且将结果往小里取整。



功能              |           示例            |    位运算
———————-+—————————+——————–
去掉最后一位          | (101101->10110)           | x shr 1
在最后加一个0         | (101101->1011010)         | x shl 1
在最后加一个1         | (101101->1011011)         | x shl 1+1
把最后一位变成1       | (101100->101101)          | x or 1
把最后一位变成0       | (101101->101100)          | x or 1-1
最后一位取反          | (101101->101100)          | x xor 1
把右数第k位变成1      | (101001->101101,k=3)      | x or (1 shl (k-1))
把右数第k位变成0      | (101101->101001,k=3)      | x and not (1 shl (k-1))
右数第k位取反         | (101001->101101,k=3)      | x xor (1 shl (k-1))
取末三位              | (1101101->101)            | x and 7
取末k位               | (1101101->1101,k=5)       | x and (1 shl k-1)
取右数第k位           | (1101101->1,k=4)          | x shr (k-1) and 1
把末k位变成1          | (101001->101111,k=4)      | x or (1 shl k-1)
末k位取反             | (101001->100110,k=4)      | x xor (1 shl k-1)
把右边连续的1变成0    | (100101111->100100000)    | x and (x+1)
把右起第一个0变成1    | (100101111->100111111)    | x or (x+1)
把右边连续的0变成1    | (11011000->11011111)      | x or (x-1)
取右边连续的1         | (100101111->1111)         | (x xor (x+1)) shr 1
去掉右起第一个1的左边 | (100101000->1000)         | x and (x xor (x-1))


判断奇偶数
if( n % 2 == 1){// n 是个奇数} //写成n % 2 的形式，编译器也会自动帮我们优化成位运算
if(n & 1 == 1){// n 是个奇数。}
交互两个变量（不用临时变量）
x = x ^ y   // （1）
y = x ^ y   // （2）
x = x ^ y   // （3）
把（1）中的 x 带入 （2）中的 x，有y = x^y = (x^y)^y = x^(y^y) = x^0 = x。 x 的值成功赋给了 y。
对于（3）,推导如下：x = x^y = (x^y)^x = (x^x)^y = 0^y = y。
异或运算支持运算的交换律和结合律哦。
两个相同的数异或之后结果会等于 0，即 n ^ n = 0。并且任何数与 0 异或等于它本身，即 n ^ 0 = n。
m的n次方
    for(int i = 1; i <= n; i++) {
        tmp = tmp * m;
    } //时间复杂度为 O(n) 

int pow(int n){
    int sum = 1;
    int tmp = m;
    while(n != 0){
        if(n & 1 == 1){
            sum *= tmp;
        }
        tmp *= tmp;
        n = n >> 1;
    }
    
    return sum;
}//时间复杂度近为 O(logn)

找出不大于N的最大的2的幂指数
最左边的 1 保留，后面的 1 全部变为 0。

   while(true){
        if(sum * 2 > N){
            return sum;
        }
        sum = sum * 2;
   }//时间复杂度是 O(logn)

1、找到最左边的 1，然后把它右边的所有 0 变成 1

2、把得到的数值加 1，可以得到 00100000即 00011111 + 1 = 00100000。

3、把 得到的 00100000 向右移动一位，即可得到 00010000，即 00100000 >> 1 = 00010000。

    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8 // 整型一般是 32 位，上面我是假设 8 位。
    return (n + 1) >> 1;

     public static int findN2(int n) {
        n |= n >> 1;
        n |= n >> 2;
       n |= n >> 4;
       n |= n >> 8;
       n |= n >> 16;
      
        return (n + 1) >> 1;
    }

//时间复杂度近似 O(1)


给定一个数，将某一位设置为1或者0
num=num|(1<<(n-1)) //设置位1
num=nun&~(1<<n-1) //设置为0

给定一个整数num，求这个整数中二进制位1的个数
int CountBitZero(int num) {
	int count = 0;
	while (num != -1) {
		++count;
		num |= num + 1;
	}
	return count;
}
x := (x and $55555555) + ((x shr 1) and $55555555);
x := (x and $33333333) + ((x shr 2) and $33333333);
x := (x and $0F0F0F0F) + ((x shr 4) and $0F0F0F0F);
x := (x and $00FF00FF) + ((x shr 8) and $00FF00FF);
x := (x and $0000FFFF) + ((x shr 16) and $0000FFFF); 


使用位运算求(a + b) / 2
// 方法一
int Avg1(int a,int b) {
	return a + ((b - a) >> 1);
}

// 方法二
int Avg2(int a, int b) {
	// a&b	=>保存同为1的位
	// a^b	=>保存相异的位
	return (a&b) + ((a^b) >> 1);
}


二进制中的1有奇数个还是偶数个
//32位的情况
int x;
scanf("%d", &x);
x ^= x >> 1;
x ^= x >> 2;
x ^= x >> 4;
x ^= x >> 8;
x ^= x >> 16;
printf("%d", x&1);

二分查找32位整数的前导0个数
int nlz(unsigned x) {
   int n;
    
   if (x == 0) return(32);
   n = 1;
   if ((x >> 16) == 0) {n = n +16; x = x <<16;}
   if ((x >> 24) == 0) {n = n + 8; x = x << 8;}
   if ((x >> 28) == 0) {n = n + 4; x = x << 4;}
   if ((x >> 30) == 0) {n = n + 2; x = x << 2;}
   n = n - (x >> 31);
   return n;
}

只用位运算来取绝对值
假设x为32位整数，则x xor (not (x shr 31) + 1) + x shr 31的结果是x的绝对值

高低位交换
(x >> 16) | (x << 16);








