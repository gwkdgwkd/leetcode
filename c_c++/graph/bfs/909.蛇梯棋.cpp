/*
给一个大小为nxn的整数矩阵board，方格按从1到n^2编号，编号遵循转行交替方式，
从左下角开始（即，从board[n-1][0]开始）的每一行改变方向。
一开始位于棋盘上的方格1。每一回合，玩家需要从当前方格curr开始出发，按下述要求前进：
选定目标方格next，目标方格的编号在范围[curr+1, min(curr+6,n^2)]。
该选择模拟了掷六面体骰子的情景，无论棋盘大小如何，玩家最多只能有6个目的地。
传送玩家：如果目标方格next处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。
否则，玩家传送到目标方格next。当玩家到达编号n^2的方格时，游戏结束。
如果board[r][c]!=-1，位于r行c列的棋盘格中可能存在“蛇”或“梯子”。
那个蛇或梯子的目的地将会是board[r][c]。编号为1和n^2的方格不是任何蛇或梯子的起点。
注意，玩家在每次掷骰的前进过程中最多只能爬过蛇或梯子一次：
就算目的地是另一条蛇或梯子的起点，玩家也不能继续移动。
举个例子，假设棋盘是[[-1,4],[-1,3]]，第一次移动，玩家的目标方格是2。
那么这个玩家将会顺着梯子到达方格3，但不能顺着方格3上的梯子前往方格4。
简单来说，类似飞行棋，玩家掷出骰子点数后移动对应格数，
遇到单向的路径（即梯子或蛇）可以直接跳到路径的终点，但如果多个路径首尾相连，也不能连续跳多个路径。
返回达到编号为n^2的方格所需的最少掷骰次数，如果不可能，则返回-1。

示例1：
输入：board = [[-1,-1,-1,-1,-1,-1],
              [-1,-1,-1,-1,-1,-1],
              [-1,-1,-1,-1,-1,-1],
              [-1,35,-1,-1,13,-1],
              [-1,-1,-1,-1,-1,-1],
              [-1,15,-1,-1,-1,-1]]
输出：4
解释：首先，从方格1[第5行，第0列]开始。
     先决定移动到方格2，并必须爬过梯子移动到到方格15。
     然后决定移动到方格17[第3行，第4列]，必须爬过蛇到方格13。
     接着决定移动到方格14，且必须通过梯子移动到方格35。
     最后决定移动到方格36, 游戏结束。
     可以证明需要至少4次移动才能到达最后一个方格，所以答案是4。

示例2：
输入：board = [[-1,-1],[-1,3]]
输出：1


提示：
n == board.length == board[i].length
2 <= n <= 20
board[i][j]的值是-1或在范围[1,n^2]内
编号为1和n^2的方格上没有蛇或梯子
*/

class Solution {
 public:
  int snakesAndLadders(vector<vector<int>>& board) {
    int n = board.size();
    vector<int8_t> vis(n * n + 1);
    vis[1] = true;        // 题目保证起点没有蛇梯，不写也可以
    vector<int> q = {1};  // 起点
    for (int step = 0; !q.empty(); step++) {
      auto tmp = q;
      q.clear();
      for (int x : tmp) {
        if (x == n * n) {  // 终点
          return step;
        }

        for (int y = x + 1; y <= min(x + 6, n * n); y++) {
          int r = (y - 1) / n, c = (y - 1) % n;
          if (r % 2) {
            c = n - 1 - c;  // 奇数行从右到左
          }
          int nxt = board[n - 1 - r][c];
          if (nxt < 0) {
            nxt = y;
          }
          if (!vis[nxt]) {
            vis[nxt] = true;  // 有环的情况下，避免死循环
            q.push_back(nxt);
          }
        }
      }
    }
    return -1;  // 无法到达终点
  }
};
