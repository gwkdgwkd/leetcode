/*
给一个下标从0开始的正整数数组nums。
如果nums的一个子数组满足：
移除这个子数组后剩余元素严格递增，那么我们称这个子数组为移除递增子数组。
比方说，[5, 3, 4, 6, 7]中的[3, 4]是一个移除递增子数组，
因为移除该子数组后，[5, 3, 4, 6, 7]变为[5, 6, 7]，是严格递增的。
请返回nums中移除递增子数组的总数目。
注意，剩余元素为空的数组也视为是递增的。
子数组指的是一个数组中一段连续的元素序列。

示例1：
输入：nums = [1,2,3,4]
输出：10
解释：10个移除递增子数组分别为：
     [1],[2],[3],[4],[1,2],[2,3],[3,4],[1,2,3],[2,3,4]和[1,2,3,4]。
     移除任意一个子数组后，剩余元素都是递增的。注意，空数组不是移除递增子数组。

示例2：
输入：nums = [6,5,7,8]
输出：7
解释：7个移除递增子数组分别为：
     [5],[6],[5,7],[6,5],[5,7,8],[6,5,7]和[6,5,7,8]。
     nums中只有这7个移除递增子数组。

示例3：
输入：nums = [8,7,6,6]
输出：3
解释：3个移除递增子数组分别为：
     [8,7,6],[7,6,6]和[8,7,6,6]。
     注意[8,7]不是移除递增子数组因为移除[8,7]后nums变为[6,6]，它不是严格递增的。


提示：
1 <= nums.length <= 10^5
1 <= nums[i] <= 10^9
*/

/*
首先讨论有多少个后缀可以移除，然后讨论一般情况。

可以移除多少个后缀？
核心思路：如果移除的是后缀，那么移除后，剩下的是前缀，且这个前缀必须是严格递增的。

设a的最长严格递增前缀的最后一个数是a[i]。
例如a=[1,3,4,1,2]，最长严格递增前缀的最后一个数是a[2]=4。

首先特判，如果i=n−1，说明a是严格递增数组，所有非空子数组都可以移除，
那么直接返回非空子数组的个数n(n+1)/2​。

接下来讨论a不是严格递增数组的情况，可以移除如下后缀（下标范围）：
[i+1,n−1]，移除该后缀，完整保留最长严格递增前缀。
[i,n−1]
[i−1,n−1]
⋯
[0,n−1]，移除整个数组。
这一共有i+2个。

一般情况：移除子数组后，剩下的部分是一个前缀加一个后缀，需要满足：
前缀是严格递增的；
后缀是严格递增的；
前缀的最后一个数严格小于后缀的第一个数。

设后缀的第一个数为a[j]，也就是说，移除的子数组的最后一个数是a[j−1]。
枚举j=n−1,n−2,n−3,⋯,1，如果a[j]≥a[j+1]则停止枚举。
对于固定的j，有多少个不同的子数组可以移除？
注意j不能为0，因为不能移除空数组。
枚举j的同时，维护最长前缀的最后一个数的下标i（满足 a[i]<a[j]），
也就是说，移除的子数组的第一个数的下标至多为i+1。
由于j越小，a[j]越小，a[i]也越小，有单调性，
所以可以像滑动窗口那样不断左移i直到i<0或者a[i]<a[j]为止。
类似移除后缀的情况，对于固定的j，可以移除如下子数组（下标区间）：
[i+1,j−1]
[i,j−1]
[i−1,j−1]
⋯
[0,j−1]
这一共有i+2个。
注意i=−1时只能移除1个子数组，即[0,j−1]，同样符合i+2这个结论，因为(−1)+2=1。
累加这些i+2，即为答案。

由于不能移除空数组，i与j的中间至少要有一个数，所以必须要有i≤j−2。
但是i=j−1的情况说明a是严格递增数组，已经在前面特判了，所以无需判断i和j−2的大小关系。
*/
class Solution {
 public:
  long long incremovableSubarrayCount(vector<int> &a) {
    int n = a.size();
    int i = 0;
    while (i < n - 1 && a[i] < a[i + 1]) {
      i++;
    }
    if (i == n - 1) {  // 每个非空子数组都可以移除
      return (long long)n * (n + 1) / 2;
    }

    long long ans = i + 2;  // 不保留后缀的情况，一共i+2个
    // 枚举保留的后缀为a[j:]
    for (int j = n - 1; j == n - 1 || a[j] < a[j + 1]; j--) {
      while (i >= 0 && a[i] >= a[j]) {
        i--;
      }
      // 可以保留前缀a[:i+1], a[:i], ..., a[:0]，一共i+2个
      ans += i + 2;
    }
    return ans;
  }
};
