/*
给一个整数数组arr和一个整数k。
设m为数组的中位数，只要满足下述两个前提之一，就可以判定arr[i]的值比arr[j]的值更强：
|arr[i] - m| > |arr[j] - m|
|arr[i] - m| == |arr[j] - m|，且arr[i] > arr[j]
请返回由数组中最强的k个值组成的列表。答案可以以任意顺序返回。
中位数是一个有序整数列表中处于中间位置的值。形式上，如果列表的长度为n，
那么中位数就是该有序列表（下标从0开始）中位于((n - 1) / 2)的元素。
例如arr = [6, -3, 7, 2, 11]，n = 5：
数组排序后得到arr = [-3, 2, 6, 7, 11]，
数组的中间位置为 m = ((5 - 1) / 2) = 2，中位数arr[m]的值为6。
例如arr = [-7, 22, 17, 3]，n = 4：
数组排序后得到arr = [-7, 3, 17, 22]，
数组的中间位置为m = ((4 - 1) / 2) = 1，中位数arr[m]的值为3。

示例1：
输入：arr = [1,2,3,4,5], k = 2
输出：[5,1]
解释：中位数为3，按从强到弱顺序排序后，数组变为[5,1,4,2,3]。
     最强的两个元素是[5, 1]。[1, 5]也是正确答案。
     注意，尽管|5 - 3| == |1 - 3|，但是5比1更强，因为5 > 1。

示例2：
输入：arr = [1,1,3,5,5], k = 2
输出：[5,5]
解释：中位数为3, 按从强到弱顺序排序后，数组变为[5,5,1,1,3]。
     最强的两个元素是[5, 5]。

示例3：
输入：arr = [6,7,11,7,6,8], k = 5
输出：[11,8,6,6,7]
解释：中位数为7, 按从强到弱顺序排序后，数组变为[11,8,6,6,7,7]。
     [11,8,6,6,7]的任何排列都是正确答案。


提示：
1 <= arr.length <= 10^5
-10^5 <= arr[i] <= 10^5
1 <= k <= arr.length
*/

class Solution {
 public:
  vector<int> getStrongest(vector<int>& arr, int k) {
    sort(arr.begin(), arr.end());
    int n = arr.size();
    vector<int> ans(k);
    int j = 0;
    int m = arr[(n - 1) / 2];
    int left = 0;
    int right = n - 1;
    while (left <= right && j < k) {
      int l = abs(arr[left] - m);
      int r = abs(arr[right] - m);
      if (l > r) {
        ans[j++] = arr[left++];
      } else {  // l <= r
        ans[j++] = arr[right--];
      }
    }
    return ans;
  }
};