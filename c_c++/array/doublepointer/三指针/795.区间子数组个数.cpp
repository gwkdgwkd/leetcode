/*
给一个整数数组nums和两个整数：left及right。
找出nums中连续、非空且其中最大元素在范围[left, right]内的子数组，
并返回满足条件的子数组的个数。
生成的测试用例保证结果符合32-bit整数范围。

示例1：
输入：nums = [2,1,4,3], left = 2, right = 3
输出：3
解释：满足条件的三个子数组：[2], [2, 1], [3]

示例2：
输入：nums = [2,9,2,5,6], left = 2, right = 8
输出：7


提示：
1 <= nums.length <= 10^5
0 <= nums[i] <= 10^9
0 <= left <= right <= 10^9
*/

/* 一次遍历
一个子数组的最大值范围在[left,right]表示子数组中不能含有大于right的元素，
且至少含有一个处于[left,right]区间的元素。
可以将数组中的元素分为三类，并分别用0, 1, 2来表示：
小于left，用0表示；
大于等于left且小于等于right，用1表示；
大于right，用2表示。

那么本题可以转换为求解不包含2，且至少包含一个1的子数组数目。
遍历i，并将右端点固定在i，求解有多少合法的子区间，过程中需要维护两个变量：
i1​，表示上一次1出现的位置，如果不存在则为−1；
i2​，表示上一次2出现的位置，如果不存在则为−1。
如果i1!=−1，那么子数组若以i为右端点，合法的左端点可以落在(last2​,last1​]之间。
这样的左端点共有i1​−i2​个。

为了保证i2​≥i1​（否则相减会算出负数），可以在nums[i]>right时也更新i2​。
也就是说，只要nums[i]≥left就更新i2​（即使>right）。

i2−i1​是怎么得出来的？
上一个不能包含的下标为i1，等价于上一个可以包含的下标为i1​+1，这是子数组左端点的最小值。
设当前遍历到下标i，那么子数组[i1+1,i],[i1​+2,i],⋯,[i2​,i]都是满足条件的，这有i2​−i1个。
*/
class Solution {
  // 时间复杂度：O(n)，其中n是nums的长度，整个过程只需要遍历一次nums。
  // 空间复杂度：O(1)，只使用到常数个变量。
 public:
  int numSubarrayBoundedMax(vector<int> &nums, int left, int right) {
    int n = nums.size(), ans = 0, i1 = -1, i2 = -1;
    for (int i = 0; i < n; ++i) {
      if (nums[i] >= left) {
        i1 = i;
      }
      if (nums[i] > right) {
        i2 = i;
      }
      ans += i1 - i2;
    }

    return ans;
  }
};