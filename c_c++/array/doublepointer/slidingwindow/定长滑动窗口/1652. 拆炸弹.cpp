/*
有一个炸弹需要拆除，时间紧迫！
情报员会给一个长度为n的循环数组code以及一个密钥k。
为了获得正确的密码，需要替换掉每一个数字。所有数字会同时被替换。
如果k > 0，将第i个数字用接下来k个数字之和替换。
如果k < 0，将第i个数字用之前k个数字之和替换。
如果k == 0，将第i个数字用0替换。
由于code是循环的，code[n-1]下个元素是code[0]，且code[0]前个元素是code[n-1]。
给循环数组code和整数密钥k，请返回解密后的结果来拆除炸弹！

示例1：
输入：code = [5,7,1,4], k = 3
输出：[12,10,16,13]
解释：每个数字都被接下来3个数字之和替换。
     解密后的密码为[7+1+4, 1+4+5, 4+5+7, 5+7+1]。注意到数组是循环连接的。

示例2：
输入：code = [1,2,3,4], k = 0
输出：[0,0,0,0]
解释：当k为0时，所有数字都被0替换。

示例3：
输入：code = [2,4,9,3], k = -2
输出：[12,5,6,13]
解释：解密后的密码为[3+9, 2+3, 4+2, 9+4]。
     注意到数组是循环连接的。如果k是负数，那么和为之前的数字。


提示：
n == code.length
1 <= n <= 100
1 <= code[i] <= 100
-(n - 1) <= k <= n - 1
*/

/*
如果k>0，例如code=[3,1,4,1,5,9], k=3：
计算ans[0]，即子数组[1,4,1]的元素和 1+4+1=6。
计算ans[1]，即子数组[4,1,5]的元素和，可以在[1,4,1]的基础上，
增加code[4]=5，减少code[1]=1，得到6+5−1=10。
计算ans[2]，即子数组[1,5,9]的元素和，可以在[4,1,5]的基础上，
增加code[5]=9，减少code[2]=4，得到10+9−4=15。
计算ans[3]，即子数组[5,9,3]的元素和，可以在[1,5,9]的基础上，
增加code[6mod6]=code[0]=3，减少code[3]=1，得到15+3−1=17。
计算ans[4]，即子数组[9,3,1]的元素和，可以在[5,9,3]的基础上，
增加code[7mod6]=code[1]=1，减少code[4]=5，得到17+1−5=13。
计算ans[5]，即子数组[3,1,4]的元素和，可以在[9,3,1]的基础上，
增加code[8mod6]=code[2]=4，减少code[5]=9，得到13+4−9=8。

对于k<0的情况也同理。注意无论k>0还是k<0，窗口都在向右移动，只有初始位置不同。
所以确定好第一个窗口的位置，就可以把k>0和k<0两种情况合并起来了：
k>0，第一个窗口的的下标范围为[1,k+1)。
k<0，第一个窗口的的下标范围为[n−∣k∣,n)。
无论k是正是负，窗口的大小都是∣k∣。

在窗口向右滑动时，设移入窗口的元素下标为r%n，则移出窗口的元素下标为(r−∣k∣)%n。
代码实现时，k=0的特判可以省略。
当k=0时，r=n, s=0, 移动时，code[r%n]=code[(r-k)%n]，所以s永远为0。
*/
class Solution {
  // 时间复杂度：O(n)，其中n为code的长度。
  // 空间复杂度：O(1)，返回值不计入。
 public:
  vector<int> decrypt(vector<int>& code, int k) {
    int n = code.size();
    vector<int> ans(n);
    int r = k > 0 ? k + 1 : n;
    k = abs(k);

    int sum = accumulate(code.begin() + r - k, code.begin() + r, 0);
    for (int i = 0; i < n; ++i) {
      ans[i] = sum;
      sum += code[r % n] - code[(r - k) % n];
      r++;
    }
    return ans;
  }
};