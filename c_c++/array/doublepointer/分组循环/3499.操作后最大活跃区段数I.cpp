/*
给一个长度为n的二进制字符串s，其中：
'1'表示一个活跃区段。
'0'表示一个非活跃区段。
可以执行最多一次操作来最大化s中的活跃区段数量。在一次操作中，可以：
将一个被'0'包围的连续'1'区块转换为全'0'。
然后，将一个被'1'包围的连续'0'区块转换为全'1'。
返回在执行最优操作后，s中的最大活跃区段数。
注意：处理时需要在s的两侧加上'1'，即t = '1' + s + '1'。
这些加上的'1'不会影响最终的计数。

示例1：
输入：s = "01"
输出：1
解释：因为没有被'0'包围的'1'区块，因此无法进行有效操作。最大活跃区段数为1。

示例2：
输入：s = "0100"
输出：4
解释：字符串"0100"→两端加上'1'后得到"101001"。
     选择"0100"，"101001" → "100001" → "111111"。
     最终的字符串去掉两端的'1'后为"1111"。最大活跃区段数为4。

示例3：
输入：s = "1000100"
输出：7
解释：字符串"1000100" → 两端加上'1'后得到"110001001"。
     选择"000100"，"110001001" → "110000001" → "111111111"。
     最终的字符串去掉两端的'1'后为"1111111"。最大活跃区段数为7。

示例4：
输入：s = "01010"
输出：4
解释：字符串"01010" → 两端加上'1'后得到"1010101"。
     选择"010"，"1010101" → "1000101" → "1111101"。
     最终的字符串去掉两端的'1'后为"11110"。最大活跃区段数为4。


提示：
1 <= n == s.length <= 10^5
s[i]仅包含'0'或'1'
*/

class Solution {
 public:
  int maxActiveSectionsAfterTrade(string s) {
    int n = s.size();
    int pre0 = INT_MIN;
    int c0 = 0;
    int c1 = 0;
    int cnt = 0;
    for (int i = 0; i < n; ++i) {
      ++cnt;
      if (i == n - 1 || s[i] != s[i + 1]) {
        if (s[i] == '1') {
          c1 += cnt;
        } else {
          c0 = max(c0, pre0 + cnt);
          pre0 = cnt;
        }
        cnt = 0;
      }
    }
    return c0 + c1;
  }
};