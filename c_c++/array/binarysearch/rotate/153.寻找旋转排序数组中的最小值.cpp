/*
已知一个长度为n的数组，预先按照升序排列，经由1到n次旋转后，得到输入数组。
例如，原数组nums = [0,1,2,4,5,6,7]在变化后可能得到：
若旋转4次，则可以得到[4,5,6,7,0,1,2]
若旋转7次，则可以得到[0,1,2,4,5,6,7]
注意，数组[a[0],a[1],a[2],...,a[n-1]]旋转一次的结果为数组：
[a[n-1],a[0],a[1],a[2],...,a[n-2]]。
给你一个元素值互不相同的数组nums，
它原来是一个升序排列的数组，并按上述情形进行了多次旋转。
请你找出并返回数组中的最小元素。
你必须设计一个时间复杂度为O(logn)的算法解决此问题。

示例1：
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为[1,2,3,4,5]，旋转3次得到输入数组。

示例2：
输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为[0,1,2,4,5,6,7]，旋转4次得到输入数组。

示例3：
输入：nums = [11,13,15,17]
输出：11
解释：原数组为[11,13,15,17]，旋转4次得到输入数组。

提示：
n == nums.length
1 <= n <= 5000
-5000 <= nums[i] <= 5000
nums中的所有整数互不相同
nums原来是一个升序排序的数组，并进行了1至n次旋转
*/

// 二分查找
int findMin(int* nums, int numsSize) {
  int left = 0;
  int right = numsSize - 1;

  // 与canfinish类型的题，写法一致
  while (left < right) {  // 不包括相等的情况
    int mid = left + (right - left) / 2;
    // canfinish简单，只是一条语句
    if (nums[mid] < nums[right]) {
      right = mid;
    } else {
      // 由于不存在重复元素，所以nums[mid]和nums[right]不会相等
      left = mid + 1;
    }
  }
  return nums[left];
}

class Solution {
  // 单调递增的序列：
  //         *
  //       *
  //     *
  //   *
  // *
  // 做了旋转：
  //   *
  // *
  //         *
  //       *
  //     *
  // 用二分法查找，需要始终将目标值（这里是最小值）套住，并不断收缩左边界或右边界。

  // 左、中、右三个位置的值相比较，有以下几种情况：
  // 1.左值<中值，中值<右值，没有旋转，最小值在最左边，可以收缩右边界
  //         右
  //      中
  //   左
  // 2.左值>中值，中值<右值，有旋转，最小值在左半边，可以收缩右边界
  //   左
  //         右
  //      中
  // 3.左值<中值，中值>右值，有旋转，最小值在右半边，可以收缩左边界
  //      中
  //   左
  //         右
  // 4.左值>中值，中值>右值，单调递减，不可能出现
  //   左
  //      中
  //         右
  // 分析前面三种可能的情况，会发现情况1、2是一类，情况3是另一类。
  // 如果中值<右值，则最小值在左半边，可以收缩右边界。
  // 如果中值>右值，则最小值在右半边，可以收缩左边界。
  // 通过比较中值与右值，可以确定最小值的位置范围，从而决定边界收缩的方向。
  // 而情况1与情况3都是左值<中值，但是最小值位置范围却不同，
  // 这说明，如果只比较左值与中值，不能确定最小值的位置范围。
  // 所以需要通过比较中值与右值来确定最小值的位置范围，进而确定边界收缩的方向。

 public:
  int findMin(vector<int>& nums) {
    int left = 0;
    // 左闭右闭区间，如果用右开区间则不方便判断右值：
    int right = nums.size() - 1;

    while (left < right) {  // 要保证左闭右开区间里面始终套住最小值
      int mid = left + (right - left) / 2;  // 向下取整的地板除，mid更靠近left
      // 再结合while循环的条件left < right，可以知道left <= mid，
      // mid < right，即在while循环内，mid始终小于right。
      // 因此在while循环内，nums[mid]要么大于要么小于nums[right]，不会等于。

      if (nums[mid] < nums[right]) {
        right = mid;
      } else {  // nums[mid] > nums[right]
        left = mid + 1;
      }
    }

    // 再分析一下while循环退出的条件，如果输入数组只有一个数，
    // 左右边界位置重合，left==right，不会进入while循环，直接输出。

    // 如果输入数组多于一个数，循环到最后，会只剩两个数，
    // nums[left]==nums[mid]，以及nums[right]，这里的位置left==mid==right-1。

    // 如果nums[left]==nums[mid]>nums[right]，则左边大、右边小，
    // 需要执行left=mid+1，使得left==right，左右边界位置重合，
    // 循环结束，nums[left]与nums[right]都保存了最小值。

    // 如果nums[left]==nums[mid]<nums[right]，则左边小、右边大，
    // 会执行right=mid，使得left==right，左右边界位置重合，
    // 循环结束，nums[left]、nums[mid]、nums[right]都保存了最小值。

    return nums[left];
  }
};