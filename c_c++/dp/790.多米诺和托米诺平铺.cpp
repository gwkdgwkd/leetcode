/*
有两种形状的瓷砖：一种是2x1的多米诺形，另一种是形如"L"的托米诺形。两种形状都可以旋转。
给定整数n，返回可以平铺2xn的面板的方法的数量。返回对109 + 7取模的值。
平铺指的是每个正方形都必须有瓷砖覆盖。
两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，
使得恰好有一个平铺有一个瓷砖占据两个正方形。

示例1:
输入: n = 3
输出: 5

示例2:
输入: n = 1
输出: 1

提示：
1 <= n <= 1000
*/

/* 动态规划
瓷砖的形状有两种，分别是2x1型和L型，并且两种瓷砖都可以旋转。
将旋转后的瓷砖分别记为1x2型和L'型。

f[i][j]表示平铺前2×i的面板，其中j表示最后一列的状态，最后一列有4种状态，分别是：
最后一列没有铺瓷砖，记为0；
最后一列只铺了上方一个瓷砖，记为1；
最后一列只铺了下方一个瓷砖，记为2；
最后一列铺满，记为0。
那么答案就是f[n][3]。初始时f[0][3]=1，其余f[0][j]=0。

考虑铺到第i列，来看看状态转移方程：
1.当j=3时，最后一列铺满，可由前一列的0,1,2,3四种状态铺上对应的瓷砖转移而来，
  即f[i−1][0]铺上1x2型瓷砖，或者f[i−1][1]铺上L'型瓷砖，
  或者f[i−1][2]铺上L'型瓷砖，或者f[i−1][0]铺上两块2x1型瓷砖。
2.当j=1时，最后一列只铺了上方一个瓷砖，可由前一列的2,0两种状态转移而来，
  即f[i−1][2]铺上2x1型瓷砖，或者f[i−1][0]铺上L型瓷砖。
  因此f[i][1]=f[i−1][2]+f[i−1][0]。
3.当j=2时，最后一列只铺了下方一个瓷砖，可由前一列的1,3两种状态转移而来，
  即f[i−1][1]铺上2x1型瓷砖，或者f[i−1][0]铺上L'型瓷砖。
  因此f[i][2]=f[i−1][1]+f[i−1][0]。
4.当j=0时，最后一列没有铺瓷砖，可由前一列的3一种状态转移而来。
  因此f[i][0]=f[i−1][3]。
可以发现，状态转移方程中只涉及到前一列的状态，因此可以使用滚动数组优化空间复杂度。
注意，过程中的状态数值可能会很大，因此需要对109+7取模。
*/
class Solution {
 public:
  const long long mod = 1e9 + 7;
  int numTilings(int n) {
    vector<vector<long long>> dp(n + 1, vector<long long>(4));
    dp[0][3] = 1;
    for (int i = 1; i <= n; i++) {
      dp[i][0] = dp[i - 1][3];
      dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % mod;
      dp[i][2] = (dp[i - 1][0] + dp[i - 1][1]) % mod;
      dp[i][3] =
          (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][3]) % mod;
    }
    return dp[n][3];
  }
};

class Solution {
 public:
  int numTilings(int n) {
    const int mod = 1e9 + 7;
    long long f[4] = {1, 0, 0, 0};
    for (int i = 1; i <= n; ++i) {
      long long g[4];
      g[0] = (f[0] + f[1] + f[2] + f[3]) % mod;
      g[1] = (f[2] + f[3]) % mod;
      g[2] = (f[1] + f[3]) % mod;
      g[3] = f[0];
      memcpy(f, g, sizeof(g));
    }
    return f[0];
  }
};

class Solution {
  const int MOD = 1'000'000'007;

 public:
  int numTilings(int n) {
    if (n == 1) {
      return 1;
    }
    vector<long long> f(n + 1);
    f[0] = f[1] = 1;
    f[2] = 2;
    for (int i = 3; i <= n; i++) {
      f[i] = (f[i - 1] * 2 + f[i - 3]) % MOD;
    }

    return f[n];
  }
};

// 矩阵快速幂