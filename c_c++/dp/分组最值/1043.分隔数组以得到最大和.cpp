/*
给你一个整数数组arr，请你将该数组分隔为长度最多为k的一些（连续）子数组。
分隔完成后，每个子数组的中的所有值都会变为该子数组中的最大值。
返回将数组分隔变换后能够得到的元素最大和。
注意，原数组和分隔后的数组对应顺序应当一致，也就是说，
你只能选择分隔数组的位置而不能调整数组中的顺序。

示例1：
输入：arr = [1,15,7,9,2,5,10], k = 3
输出：84
解释：
因为k=3可以分隔成[1,15,7] [9] [2,5,10]，结果为[15,15,15,9,10,10,10]，
和为84，是该数组所有分隔变换后元素总和最大的。
若是分隔成[1] [15,7,9] [2,5,10]，
结果就是[1, 15, 15, 15, 10, 10, 10]但这种分隔方式的元素总和（76）小于上一种。

示例2：
输入：arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4
输出：83

示例3：
输入：arr = [1], k = 1
输出：1

提示：
1 <= arr.length <= 500
0 <= arr[i] <= 10^9
1 <= k <= arr.length
*/

// 将数组分割为m段，求……是动态规划题目常见的问法。

// 动态规划
int maxSumAfterPartitioning(int* arr, int arrSize, int k) {
  // dp[i]：数组的前i个数即nums[0,1...i−1]，被切了Y−1刀，分割成Y个数组，
  // 满足每个数组的个数最大值不超过K，每个数组的值变成最大值，分割后的最大和。
  int dp[arrSize + 1];
  memset(dp, 0, sizeof(dp));
  // dp[0] = 0;

  for (int i = 1; i <= arrSize; ++i) {
    int tempMax = arr[i - 1];
    for (int j = 1; j <= k; ++j) {
      if (i >= j) {
        tempMax = fmax(tempMax, arr[i - j]);
        dp[i] = fmax(dp[i], dp[i - j] + tempMax * j);
      }
      printf("\n");
    }
  }

  return dp[arrSize];
}

// 预备知识：统计区间元素个数
// 分别求区间[1,5]和区间[1,5)的元素个数，前者是5个，后者是4个。
// 所列出的是两类非常典型的区间：闭区间、左闭右开。
// 要根据实际情况选择合适的区间描述方法：
// 1.对于闭区间[1,5]，计数为5−1+1=5（+1是因为只统计了单侧端点）。
// 2.对于左闭右开区间[1,5)，计数为5−1=5（恰恰只需计入左侧端点）。
// 左闭右开区间，统计区间元素更加简洁，此外，还有空区间便于描述的好处：
// [0,0)表示空区间（统一），如果闭区间表示法想表示空区间的话，只能分类讨论。

// 思路：
// 由题知，对于任意元素，均落在大小不超过上限k的子数组中，
// 故设dp[i]是划分区间[0:i)所得的最大和，最终返回dp[n]。
// 对于通项dp[i]，以元素nums[i−1]为切入点，设其为某一子数组的右端点，
// 那么该子数组的大小可能为1,2,⋯,k,针对k种情况进行枚举，便得到状态转移方程：
// dp[i]={dp[j]+区间[j,i)最大值×区间元素个数}，j的范围是[0,i-1]。
// 关于逆向遍历的说明：
// 逆向遍历，对于区间[j,i)是扩张的，因而求区间最大值可以借鉴打擂台算法的思想，
// 做到求最大值的时间复杂度达到O(1)，最终时间复杂度是双层循环嵌套即为O(n^2)。
// 否则将j遍历一趟复杂度是O(n)，嵌套在遍历中的求最大值的复杂度为O(n)，
// 那么确定一项dp[i]的复杂度达到O(n^2)，总的时间复杂度会差到O(n^3)。
class Solution {
 public:
  int maxSumAfterPartitioning(vector<int>& arr, int k) {
    int n = arr.size();
    vector<int> dp(n + 1, 0);
    // dp[i]记录划分[0:i)所得的最大和
    for (int i = 1; i <= n; i++) {
      int vmax = 0;
      for (int j = i - 1; j >= 0; j--) {
        if (i - j > k) break;
        vmax = max(vmax, arr[j]);
        // dp[j] + (i - j) * vmax : dp[j] + 区间[j,i)最大值×区间元素个数
        dp[i] = max(dp[i], dp[j] + (i - j) * vmax);
      }
    }
    // dp[n]含义是划分[0:n)所得最大和，契合题意
    return dp[n];
  }
};
