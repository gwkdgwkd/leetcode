/*
给定一个整数n，计算所有小于等于n的非负整数中数字1出现的个数。

示例1：
输入：n = 13
输出：6

示例2：
输入：n = 0
输出：0

提示：0 <= n <= 10^9
*/

// 剑指Offer431～n整数中1出现的次数

int countDigitOne(int n) {
  long long mulk = 1;
  int ans = 0;
  for (int k = 0; n >= mulk; ++k) {
    ans += (n / (mulk * 10)) * mulk +
           fmin(fmax(n % (mulk * 10) - mulk + 1, 0LL), mulk);
    mulk *= 10;
  }
  return ans;
}

// 思路：
// 枚举每一个数位，分别统计该数位上数字1出现的次数，
// 最后将所有数位统计出的次数进行累加即可得到答案。
// 以n=1234567为例，统计百位上数字1出现的次数：
// 1.对于从0开始每1000个数，百位上的数字1都会出现100次，
//   即数的最后三位每1000个数都呈现[000,999]的循环，
//   其中的[100,199]在百位上的数字为1，共有100个。
//   n拥有1234个这样的循环，每个循环百位上都出现了100次1，
//   这样就一共出现了1234×100次1。
//   公式表示：(n/1000)*100
// 2.对于剩余不在完整的循环中的部分，最后三位为[000,567]，
//   其中567可以用mod=n%1000表示，这部分的1可以分为三类：
//   a.当mod<100时，百位上不会出现1；
//   b.当100<=mod<200时，百位上出现1的范围为[100,mod]，
//     所以出现了mod-100+1次1；
//   c.当mod>=200时，百位上出现了全部100次1。
//   可以总结归纳出这一部分在百位上1的出现次数为：
//   min(max(mod-100+1,0),100)
// 百位数上出现的1的个数为：
// (n/1000)*100+min(max(n%1000-100+1,0),100)
// 通用的公式为，k表示位数：
// (n/(10^(k+1)))*(10^k)+min(max(n%(10^(k+1))-(10^k)+1,0),(10^k))
class Solution {
 public:
  int countDigitOne(int n) {
    long mulk = 1;  // 位数，1表示个位
    int ans = 0;

    while (n >= mulk) {  // 从低往高位，计算每一位的数量
      // 1*mulk中的1表示查找1的个数，如果是2，表示2的个数：
      ans += (n / (mulk * 10)) * mulk +
             min(max(n % (mulk * 10) - 1 * mulk + 1, 0L), mulk);
      mulk *= 10;
    }

    return ans;
  }
};